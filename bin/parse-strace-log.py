#!/usr/bin/env python
# -*- coding: utf-8 -*-

# Copyright 2013,2014 Marko Dimjašević, Simone Atzeni, Ivo Ugrina, Zvonimir Rakamarić
#
# This file is part of maline.
#
# maline is free software: you can redistribute it and/or modify it
# under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# maline is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with maline.  If not, see <http://www.gnu.org/licenses/>.


import argparse
import fcntl
import os
import signal
import string
import sys

# Output file
f = None

# missing-calls.txt
mf = None

# Completion flag
Done = False

# Default signal handler
def handler(signum, frame):
    if f != None:
        fcntl.flock(f.fileno(), fcntl.LOCK_UN)
        f.close()
    if mf != None:
        fcntl.flock(mf.fileno(), fcntl.LOCK_UN)
        mf.close()
    if Done:
        sys.exit(0)
    else:
        sys.exit(1)

class strace_log_parser:
    """Class for parsing log files generated by strace"""
    def __init__(self, log_file_name, architecture):
        self.log_file_name = log_file_name
        self.architecture = architecture
        self.sys_call_dict = {}
        self.sys_call_made = []
        self.import_sys_call_list()

    def import_sys_call_list(self):

        count = 0
        try:
            maline_path = os.getenv('MALINE')
            assert maline_path != 'None'
        except:
            print "Variable MALINE not set! Exiting ..."
            sys.exit(1)

        with open(os.path.join(maline_path, "data", self.architecture + "-syscall.txt"), 'r') as sc:
            for line in sc:
                self.sys_call_dict[line[:-1]] = count
                count += 1

    def mysplit(self, s, delim=None):
        return [x for x in s.split(delim) if x]

    def extract_sys_call_name(self, line):
        if line[0] != '[':
            return None

        if len(self.mysplit(line, " ")) < 4:
            return None

        sys_call = self.mysplit(line, " ")[3].split("(")[0]
        if sys_call[0] in "<+-=?0" or sys_call == "restart_syscall":
            return None

        sys_call = sys_call.lstrip('_')
        return sys_call

    def extract_sys_calls(self):
        with open(self.log_file_name, 'r') as f:
            for line_nl in f:
                sys_call = self.extract_sys_call_name(line_nl)
                if sys_call == None:
                    continue
                self.sys_call_made.append(sys_call)

    def distance_function(self, pos1, pos2):
        if pos1 == pos2:
            return 0
        return 1. / abs(pos1 - pos2)

    def print_graph(self, output_filename):
        from sets import Set
        
        f = open(output_filename, 'w')
        # Make sure no one else is messing with the file
        fcntl.flock(f.fileno(), fcntl.LOCK_EX)

        f.write('%d\n' % len(self.sys_call_dict))

        dep_graph_weight = [[0 for i in range(len(self.sys_call_dict))] for j in range(len(self.sys_call_dict))]

        not_found_calls = Set()

        for s1_pos in range(len(self.sys_call_made)):
            s1 = self.sys_call_made[s1_pos]
            if s1 not in self.sys_call_dict:
                not_found_calls.add(s1)
                continue
            index1 = self.sys_call_dict[s1]

            for s2_pos in range(s1_pos + 1, len(self.sys_call_made)):
                s2 = self.sys_call_made[s2_pos]
                if s1 == s2:
                    break
                if s2 not in self.sys_call_dict:
                    not_found_calls.add(s2)
                    continue
                index2 = self.sys_call_dict[s2]
                dep_graph_weight[index1][index2] += self.distance_function(s1_pos, s2_pos)

        # Output weights as a single row
        for i in range(len(self.sys_call_dict)):
            for j in range(len(self.sys_call_dict)):
                f.write("%f " % dep_graph_weight[i][j])

        # Print out system calls observed in the log file, but not
        # found in the system call list
        
        mf = open(os.path.join(os.getenv('MALINE'), 'missing-calls.txt'), 'a')
        fcntl.flock(mf.fileno(), fcntl.LOCK_EX)
        
        for call in not_found_calls:
            mf.write(call + "\n")

        Done = True
    
if __name__ == "__main__":

    signal.signal(signal.SIGTERM, handler)
    signal.signal(signal.SIGTSTP, handler)
    signal.signal(signal.SIGINT,  handler)
    signal.signal(signal.SIGQUIT, handler)

    parser = argparse.ArgumentParser(description='Parses a system call log file generated during an app execution')
    parser.add_argument('--file', required=True, help='A system log file to be parsed')
    parser.add_argument('--architecture', default='i386', choices=['i386'], help='Architecture of Android the app was analyzed under')
    params = parser.parse_args()

    log_parser = strace_log_parser(params.file, params.architecture)
    log_parser.extract_sys_calls()
    log_parser.print_graph(params.file[:-4] + '.graph')
