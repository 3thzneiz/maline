#!/usr/bin/env python

# Copyright 2013,2014 Marko Dimjašević, Simone Atzeni, Ivo Ugrina, Zvonimir Rakamarić
#
# This file is part of maline.
#
# maline is free software: you can redistribute it and/or modify it
# under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# maline is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with maline.  If not, see <http://www.gnu.org/licenses/>.


# To use this program, simply run it from the command line with one
# argument that is an strace log file

import sys
import string
# from parse import compile
# import parse

class strace_log_parser:
    """Class for parsing log files generated by strace"""
    def __init__(self, log_file_name):
        self.log_file_name = log_file_name
        self.sys_call_dict = {}
        self.sys_call_made = []
        self.import_sys_call_list()

    def import_sys_call_list(self):
        count = 0
        # This system call list was obtained from:
        # https://code.google.com/p/android-source-browsing/source/browse/libc/SYSCALLS.TXT?spec=svn.platform--bionic.70b1668a76d3b719ae690903ea790fda964a5458&repo=platform--bionic&r=70b1668a76d3b719ae690903ea790fda964a5458
        # It was also manually edited to fit logs obtained with strace
        with open("../data/syscalls-list", 'r') as f:
            for line in f:
                self.sys_call_dict[line[:-1]] = count
                count += 1

    def mysplit(self, s, delim=None):
        return [x for x in s.split(delim) if x]

    def extract_sys_call_name(self, line):
        if line[0] != '[':
            return None

        if len(self.mysplit(line, " ")) < 4:
            return None

        sys_call = self.mysplit(line, " ")[3].split("(")[0]
        if sys_call[0] in "<+-=?0" or sys_call == "restart_syscall":
            return None

        sys_call = sys_call.lstrip('_')
        return sys_call

    def extract_sys_calls(self):
        with open(self.log_file_name, 'r') as f:
            for line_nl in f:
                sys_call = self.extract_sys_call_name(line_nl)
                if sys_call == None:
                    continue
                self.sys_call_made.append(sys_call)

    def distance_function(self, pos1, pos2):
        if pos1 == pos2:
            return 0
        return 1. / abs(pos1 - pos2)

    def print_graph(self, output_filename):
        from sets import Set
        
        f = open(output_filename, 'w')
        f.write('%d\n' % len(self.sys_call_dict))

        dep_graph_weight = [[0 for i in range(len(self.sys_call_dict))] for j in range(len(self.sys_call_dict))]
        dep_graph_count  = [[0 for i in range(len(self.sys_call_dict))] for j in range(len(self.sys_call_dict))]

        not_found_calls = Set()

        for s1_pos in range(len(self.sys_call_made)):
            s1 = self.sys_call_made[s1_pos]

            if s1 not in self.sys_call_dict:
                not_found_calls.add(s1)
                continue
            index1 = self.sys_call_dict[s1]
            for s2_pos in range(s1_pos + 1, len(self.sys_call_made)):
                s2 = self.sys_call_made[s2_pos]
                if s2 not in self.sys_call_dict:
                    not_found_calls.add(s2)
                    continue
                if s1 == s2:
                    break
                index2 = self.sys_call_dict[s2]
                dep_graph_weight[index1][index2] += self.distance_function(s1_pos, s2_pos)
                dep_graph_count[index1][index2] += 1

        # Output weights
        for i in range(len(self.sys_call_dict)):
            for j in range(len(self.sys_call_dict)):
                if j > 0:
                    f.write(" ")
                f.write("%f" % dep_graph_weight[i][j])
            f.write("\n")

        f.write("\n")
        # Output counts
        for i in range(len(self.sys_call_dict)):
            for j in range(len(self.sys_call_dict)):
                if j > 0:
                    f.write(" ")
                f.write("%d" % dep_graph_count[i][j])
            f.write("\n")
        f.close()

        # Print out system calls observed in the log file, but not
        # found in syscalls-list
        with open('missing-calls.txt', 'a') as f:
            for call in not_found_calls:
                f.write(call + "\n")
        # print "System calls observed, but not on the list: " + str(not_found_calls)

if __name__ == "__main__":
    assert (len(sys.argv) == 2)
    parser = strace_log_parser(sys.argv[1])
    parser.extract_sys_calls()
    parser.print_graph(sys.argv[1][:-4] + '.graph')
